/// <reference lib="webworker" />

import { clientsClaim } from "workbox-core";
import { precacheAndRoute } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import {
  NetworkFirst,
  CacheFirst,
  StaleWhileRevalidate,
} from "workbox-strategies";
import { ExpirationPlugin } from "workbox-expiration";
import { CacheableResponsePlugin } from "workbox-cacheable-response";

// Take control of all pages immediately
clientsClaim();

// Skip waiting on install
self.addEventListener("install", () => {
  self.skipWaiting();
});

declare let self: ServiceWorkerGlobalScope;

// Precache all assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST || []);

// Cache the GitHub API responses
registerRoute(
  ({ url }) => url.origin === "api.github.com",
  new NetworkFirst({
    cacheName: "github-api-cache",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
      }),
    ],
  })
);

// Cache static assets
registerRoute(
  ({ request }) =>
    request.destination === "style" ||
    request.destination === "script" ||
    request.destination === "image",
  new CacheFirst({
    cacheName: "static-assets",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
      }),
    ],
  })
);

// Cache HTML pages with StaleWhileRevalidate
registerRoute(
  ({ request }) => request.mode === "navigate",
  new StaleWhileRevalidate({
    cacheName: "pages-cache",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Skip waiting and claim clients
self.addEventListener("install", (event) => {
  event.waitUntil(
    Promise.all([
      // Cache core assets
      caches.open("core-cache").then((cache) => {
        return cache.addAll([
          "/",
          "/index.html",
          "/manifest.json",
          "/favicon.ico",
        ]);
      }),
      self.skipWaiting(),
    ])
  );
});

self.addEventListener("activate", (event) => {
  event.waitUntil(
    Promise.all([
      // Clean up old caches
      caches.keys().then((cacheNames) => {
        return Promise.all(
          cacheNames.map((cacheName) => {
            // Delete old caches except the current ones
            if (
              ![
                "core-cache",
                "pages-cache",
                "static-assets",
                "github-api-cache",
              ].includes(cacheName)
            ) {
              return caches.delete(cacheName);
            }
          })
        );
      }),
      // Take control of all clients
      self.clients.claim(),
    ])
  );
});

// Offline fallback
self.addEventListener("fetch", (event: FetchEvent) => {
  if (event.request.mode === "navigate") {
    event.respondWith(
      fetch(event.request).catch(() =>
        caches.match("/index.html").then((response) => {
          if (response) {
            return response;
          }
          return new Response("Offline page not available", {
            status: 503,
            statusText: "Service Unavailable",
          });
        })
      )
    );
  }
});
